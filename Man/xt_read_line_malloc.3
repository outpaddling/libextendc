\" Generated by c2man from xt_read_line_malloc.c
.TH xt_read_line_malloc 3

.SH NAME

xt_read_line_malloc() - Read a line and allocate memory for it

.SH LIBRARY
\" Indicate #includes, library name, -L and -l flags
.nf
.na
#include <xtend/file.h>
-lxtend
.ad
.fi

\" Convention:
\" Underline anything that is typed verbatim - commands, etc.
.SH SYNOPSIS
.nf
.na
int     xt_read_line_malloc(FILE *stream, char **buff, size_t *buff_size,
size_t *len)
.ad
.fi

.SH ARGUMENTS
.nf
.na
stream:     FILE stream from which field is read
buff:       Character buffer into which field is copied
buff_size:  Size of the array passed to buff
len:        Pointer to a variable which will receive the field length
.ad
.fi

.SH DESCRIPTION

.B xt_read_line_malloc()
reads a single line of text (up to the next newline or EOF)
from stream, allocating and/or extending the provided buffer if
needed.

The buff_size argument must be initilized to 0 if buff has
not been previously allocated.  This will cause an initial
allocation to occur.  If buff has been previously allocated,
the buff_size must accurately reflect the allocated memory size.
This will happen naturally when reusing buff in a loop, as shown
in the example below.

.SH RETURN VALUES

Delimiter ending the read: either newline or EOF

.SH EXAMPLES
.nf
.na

FILE    *stream;
char    *buff;
size_t  buff_len, len;

// Reuse buff to minimize malloc() calls.  buff will be extended
// as needed when longer strings are read.  Initialize buff here
// rather than above for the most cohesive code.
buff_len = 0;
while ( ffile_read_line_malloc(stream, buff, &buff_len, &len) != EOF )
{
}
.ad
.fi

.SH SEE ALSO

dsv_read_field_malloc(3), ffgetc(3)

