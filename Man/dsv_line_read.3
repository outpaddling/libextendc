\" Generated by c2man from dsv_line_read.c
.TH dsv_line_read 3

.SH NAME
dsv_line_read() - Read a line of generic tabular data

.SH LIBRARY
\" Indicate #includes, library name, -L and -l flags
.nf
.na
#include <xtend/dsv.h>
-lbiolibc
.ad
.fi

\" Convention:
\" Underline anything that is typed verbatim - commands, etc.
.SH SYNOPSIS
.nf
.na
int     dsv_line_read(dsv_line_t *dsv_line, FILE *stream, const char *delims)
.ad
.fi

.SH ARGUMENTS
.nf
.na
dsv_line    Pointer to a dsv_line_t structure to hold the fields
stream      FILE stream from which the line is read
delims      Array of acceptable delimiters
.ad
.fi

.SH DESCRIPTION

Read a line of an arbitrary DSV file into a dsv_line_t object.
Memory is allocated for the text of the fields, and it must
be freed using fsv_line_free(3) before calling
dsv_line_read(3) on the same object again.

The dsv_line_t structure contains an array of strings, each
holding one field from the line, and an an array of delimiters,
each holding the character that ended the corresponding field.
Note that each field could potentially end with a different
delimiter, as multiple delimiters can be specified.

This function serves a purpose similar to the split() functions
present in many languages.  However, it does not need to read an
entire line into a character array and then split the array.
Instead, it separates fields as they are read from the input stream.

.SH RETURN VALUES

Actual delimiter of last field (should be newline)

.SH EXAMPLES
.nf
.na

dsv_line_t  *line = dsv_line_new();

while ( dsv_line_read(line, stdin, "\\t") != EOF )
{
    dsv_line_write(line, stdout);
    dsv_line_free(line);
}
.ad
.fi

.SH SEE ALSO

dsv_line_new(3), dsv_line_free(3),
dsv_line_read(3), dsv_line_write(3), dsv_line_copy(3),
dsv_read_field(3), dsv_read_field_malloc(3),
dsv_skip_field(3), dsv_skip_rest_of_line(3)

